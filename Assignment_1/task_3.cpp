#include <iostream>   // Подключение библиотеки для ввода и вывода
#include <random>     // Подключение библиотеки для генерации случайных чисел
#include <chrono>     // Подключение библиотеки для измерения времени
#include <omp.h>      // Подключение библиотеки OpenMP
#include <iomanip>    // Подключение библиотеки для форматированного вывода

using namespace std;  // Использование стандартного пространства имён

int task3() { // Функция для выполнения задания 3

    constexpr int SIZE = 1'000'000;       // Размер массива (1 000 000 элементов)
    constexpr int RAND_MIN_VAL = 1;        // Минимальное значение диапазона
    constexpr int RAND_MAX_VAL = 1000;      // Максимальное значение диапазона

    int* arr = new int[SIZE];              // Динамическое выделение памяти под массив

    random_device rd;                      // Источник энтропии
    mt19937 gen(rd());                     // Генератор случайных чисел
    uniform_int_distribution<> dist(RAND_MIN_VAL, RAND_MAX_VAL); // Равномерное распределение

    for (int i = 0; i < SIZE; i++) {       // Заполнение массива случайными числами
        arr[i] = dist(gen);                // Генерация и запись значения
    }

    // ======================================================
    // ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК MIN И MAX
    // ======================================================

    auto start_seq = chrono::high_resolution_clock::now(); // Начало измерения времени (SEQ)

    int min_seq = arr[0];                  // Начальное значение минимума
    int max_seq = arr[0];                  // Начальное значение максимума

    for (int i = 1; i < SIZE; i++) {       // Последовательный обход массива
        if (arr[i] < min_seq) {            // Проверка на минимум
            min_seq = arr[i];              // Обновление минимума
        }
        if (arr[i] > max_seq) {            // Проверка на максимум
            max_seq = arr[i];              // Обновление максимума
        }
    }

    auto end_seq = chrono::high_resolution_clock::now(); // Конец измерения времени (SEQ)
    chrono::duration<double> time_seq = end_seq - start_seq; // Время выполнения SEQ

    // ======================================================
    // ПАРАЛЛЕЛЬНЫЙ ПОИСК MIN И MAX (OpenMP)
    // ======================================================

    auto start_par = chrono::high_resolution_clock::now(); // Начало измерения времени (OMP)

    int min_par = arr[0];                  // Начальное значение минимума
    int max_par = arr[0];                  // Начальное значение максимума

    #pragma omp parallel for reduction(min:min_par) reduction(max:max_par)
    for (int i = 0; i < SIZE; i++) {       // Параллельный обход массива
        if (arr[i] < min_par) {            // Локальная проверка минимума
            min_par = arr[i];              // Обновление минимума
        }
        if (arr[i] > max_par) {            // Локальная проверка максимума
            max_par = arr[i];              // Обновление максимума
        }
    }

    auto end_par = chrono::high_resolution_clock::now(); // Конец измерения времени (OMP)
    chrono::duration<double> time_par = end_par - start_par; // Время выполнения OMP

    // ======================================================
    // ВЫВОД РЕЗУЛЬТАТОВ
    // ======================================================

    cout << fixed << setprecision(10);     // Формат вывода времени

    cout << "Последовательный поиск." << endl;
    cout << "Минимальное значение: " << min_seq << endl; // Вывод минимума (SEQ)
    cout << "Максимальное значение: " << max_seq << endl; // Вывод максимума (SEQ)
    cout << "Время выполнения: " << time_seq.count() << " секунды\n" << endl;

    cout << "Параллельный поиск с использованием OpenMP." << endl;
    cout << "Минимальное значение: " << min_par << endl; // Вывод минимума (OMP)
    cout << "Максимальное значение: " << max_par << endl; // Вывод максимума (OMP)
    cout << "Время выполнения: " << time_par.count() << " секунды\n" << endl;

    delete[] arr;                          // Освобождение динамически выделенной памяти
    cout << "Динамическая память успешно освобождена." << endl; // Сообщение об освобождении памяти

    return 0;                              // Завершение функции
}

int main() {          // Главная функция программы
    task3();          // Вызов функции задания 3
    return 0;         // Завершение работы программы
}
