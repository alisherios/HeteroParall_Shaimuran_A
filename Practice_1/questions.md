# Контрольные вопросы к Практическая работа №1 (Введение в основы C/C++ и структуры данных)
## 1. В чём основные отличия между массивами и динамическими структурами данных?
Главное отличие заключается в **управлении памятью и гибкости**:

**Массивы (статические)**: Размер задается при компиляции или создании и не может быть изменен. Элементы хранятся в непрерывных блоках памяти, что обеспечивает быстрый доступ по индексу (O(1)). Недостаток — нельзя легко изменить размер массива.

**Динамические структуры (списки, деревья, очереди)**: Могут расти и уменьшаться во время работы программы. Элементы могут быть разбросаны в памяти, что делает вставку и удаление элементов более гибкой (O(1) для списка), но доступ по индексу медленнее (O(n)).

## 2. Что такое указатель, и как он используется в языке C++?
**Указатель** — это переменная, значением которой является адрес ячейки памяти, где хранятся данные другой переменной. В C++ они используются для:
* Динамического выделения памяти (оператор new).
* Передачи больших объектов в функции без их копирования (по адресу).
* Создания сложных структур данных (связные списки, графы).
* Прямого доступа к аппаратным ресурсам.
  
```cpp
int* ptr = new int; // выделение памяти
*ptr = 10;          // запись значения через указатель
delete ptr;         // освобождение памяти
```

## 3. Объясните принцип работы стека и очереди.
Это структуры с разными правилами доступа к данным:

**Стек (LIFO — Last In, First Out)**: «Последним пришел — первым ушел». Представь стопку тарелок: ты кладешь новую наверх и снять можешь только верхнюю.
* Добавление: push — кладём элемент наверх стека
* Удаление: pop — снимаем верхний элемент

**Очередь (FIFO — First In, First Out)**: «Первым пришел — первым ушел». Как обычная очередь в магазине: кто первый встал, того первого и обслужили.
* Добавление: enqueue — кладём элемент в конец очереди
* Удаление: dequeue — забираем элемент с начала очереди

## 4. Каковы преимущества и недостатки односвязных списков по сравнению с массивами?

**Преимущества**:
* Динамическая память, можно добавлять и удалять элементы без сдвига всех остальных.
* Эффективны для структур с частыми вставками и удалениями.

**Недостатки**:
* Больше памяти нужно для хранения указателей.
* Медленный доступ к элементу по индексу (O(n) против O(1) у массива).
* Нет непрерывного блока памяти → меньше кэш-локальности.
  
## 5. Как правильно освобождать память в языке C++ после работы с динамическими структурами?
Для освобождения памяти используются операторы, соответствующие способу выделения:

* Если выделяли один объект:
```cpp
int* ptr = new int;
delete ptr;   // освобождение памяти
```
* Если выделяли массив:
```cpp
int* arr = new int[N];
delete[] arr; // освобождение памяти
```
* Важно: После ```delete``` хорошей практикой считается присвоить указателю значение ```nullptr```, чтобы избежать ошибок «висячих указателей».
* Для структур данных (списки, стек, очередь) — в деструкторе необходимо пройтись по всем элементам и удалить их, чтобы избежать утечек памяти.

## 6. Почему важно понимать работу с указателями и динамической памятью для параллельного программирования?
* В параллельном программировании несколько потоков могут одновременно работать с данными.
* Указатели позволяют создавать динамические структуры, к которым потоки могут безопасно обращаться через мьютексы или атомарные операции.
* Понимание памяти помогает избежать гонок данных, утечек и неопределённого поведения при параллельной обработке.

## 7. Как использовать reduction в OpenMP для нахождения суммы, минимума или максимума в массиве?
* ```reduction``` создаёт локальные копии переменной для каждого потока, которые объединяются после выполнения параллельного участка.
  
Пример нахождения суммы:
```cpp
int sum = 0;
#pragma omp parallel for reduction(+:sum)
for(int i = 0; i < N; i++)
    sum += arr[i];
```
Аналогично для минимума:
```cpp
int min_val = INT_MAX;
#pragma omp parallel for reduction(min:min_val)
for(int i = 0; i < N; i++)
    if(arr[i] < min_val) min_val = arr[i];
```
Это избавляет от необходимости использовать critical секции, которые сильно замедляют код.

## 8. Как влияет параллельное программирование на производительность при работе с большими массивами?
Позволяет распределять вычисления на несколько потоков, что ускоряет выполнение.

Эффективность зависит от:
* Количества потоков и ядер CPU
* Баланса работы между потоками
* Наличия блокировок и синхронизации (мьютексы могут снизить ускорение)

При больших объёмах данных ускорение может быть значительным, особенно для независимых операций (например, суммирование или поиск максимума).
