#include <iostream>     // Подключение стандартной библиотеки ввода-вывода (cin, cout)
#include <vector>       // Подключение контейнера vector для динамических массивов
#include <mutex>        // Подключение мьютексов для синхронизации потоков
#include <chrono>       // Подключение библиотеки для работы со временем и измерения производительности
#include <random>       // Подключение библиотеки для генерации случайных чисел (современный C++)
#include <cstdlib>      // Подключение стандартных функций C (rand, srand, exit и др.)
#include <ctime>        // Подключение функций работы с текущим временем (time)

// Проверка, определён ли макрос _OPENMP (компилятор поддерживает OpenMP)
#ifdef _OPENMP
#include <omp.h>        // Подключение библиотеки OpenMP для параллельного программирования
#endif

using namespace std;    // Использование стандартного пространства имён std

// --- Настройки диапазона случайных чисел ---
constexpr int RAND_MIN_VAL = 1;         // <-- менять здесь минимум диапазона
constexpr int RAND_MAX_VAL = 1000;      // <-- менять здесь максимум диапазона

// Создание псевдонима (alias) clk для класса chrono::high_resolution_clock,
// который используется для высокоточного измерения времени выполнения программы
using clk = chrono::high_resolution_clock;

// ================================================================
// SINGLE LINKED LIST
// ================================================================

struct Node {
    int data;       // Поле для хранения значения узла (целое число)
    Node* next;     // Указатель на следующий элемент односвязного списка
    Node(int v) : data(v), next(nullptr) {}
    // Конструктор структуры:
    // v — значение, передаваемое в узел
    // data(v) — инициализация поля data переданным значением
    // next(nullptr) — инициализация указателя на следующий узел как пустого
};

class LinkedList {
    // Объявление класса LinkedList для реализации односвязного списка
private:
    Node* head;// Указатель на первый элемент (голову) односвязного списка
    int sz; // Переменная для хранения текущего количества элементов в списке
    mutex mtx;
    // Мьютекс для обеспечения потокобезопасного доступа к списку
    // Используется при параллельной работе (например, с OpenMP)

public:
    // Открытая секция класса (доступна извне)
    LinkedList() : head(nullptr), sz(0) {}
    // Конструктор класса LinkedList:
    // head(nullptr) — инициализация указателя на голову списка как пустого
    // sz(0) — начальный размер списка равен 0

    ~LinkedList() {
        // Деструктор класса LinkedList, вызывается при уничтожении объекта

        while (head) {
            // Цикл выполняется, пока в списке есть элементы
            Node* tmp = head;// Временный указатель для сохранения текущего узла
            head = head->next;// Переход к следующему узлу списка
            delete tmp; // Освобождение памяти, занятой текущим узлом
        }
    }

    void add(int value) {
        // Метод добавления нового элемента в начало односвязного списка
        lock_guard<mutex> lock(mtx);
        // Объект lock_guard автоматически блокирует мьютекс mtx
        // и гарантирует его разблокировку при выходе из области видимости

        Node* node = new Node(value); // Динамическое создание нового узла со значением value
        node->next = head; // Новый узел указывает на текущую голову списка
        head = node; // Новый узел становится новой головой списка
        sz++; // Увеличение счётчика количества элементов списка
    }

    bool remove() {
        // Метод удаления элемента из начала односвязного списка
        lock_guard<mutex> lock(mtx); // Блокировка мьютекса для обеспечения потокобезопасного доступа к списку
        if (!head) return false;
        // Проверка: если список пуст (head == nullptr),
        // удаление невозможно — возвращается false
        Node* tmp = head; // Временный указатель на текущую голову списка
        head = head->next; // Сдвиг головы списка на следующий элемент
        delete tmp; // Освобождение памяти, занятой удаляемым узлом
        sz--; // Уменьшение счётчика количества элементов в списке
        return true; // Возврат значения true, если удаление прошло успешно
    }
    bool search(int value) {
        // Метод поиска элемента со значением value в односвязном списке
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для безопасного доступа к списку
        // при работе в многопоточном режиме
        Node* cur = head;
        // Указатель на текущий узел, начиная с головы списка
        while (cur) {
            // Цикл обхода списка, выполняется пока текущий узел существует
            if (cur->data == value) return true;
            // Если значение текущего узла совпадает с искомым,
            // поиск завершается и возвращается true
            cur = cur->next;
            // Переход к следующему узлу списка
        }
        return false;
        // Если элемент не найден после обхода всего списка,
        // возвращается false
    }
    int size() {
        // Метод для получения текущего количества элементов в списке
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного чтения значения sz
        return sz;
        // Возврат текущего размера односвязного списка
    }
};

// ================================================================
// STACK
// ================================================================
class Stack {
    // Класс Stack реализует стек на основе контейнера vector
private:
    vector<int> data;
    // Вектор для хранения элементов стека
    mutex mtx;
    // Мьютекс для потокобезопасного доступа к стеку

public:
    void push(int v) {
        // Метод добавления элемента в стек (на вершину)
        lock_guard<mutex> lock(mtx);
        // Автоматическая блокировка мьютекса для безопасного добавления элемента
        data.push_back(v);
        // Добавление элемента v в конец вектора (вершина стека)
    }

    bool pop() {
        // Метод удаления элемента с вершины стека
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для безопасного удаления элемента
        if (data.empty()) return false;
        // Если стек пуст, возвращается false (удаление невозможно)
        data.pop_back();
        // Удаление последнего элемента вектора (вершины стека)
        return true;
        // Возврат true, если удаление прошло успешно
    }
    bool isEmpty() {
        // Метод проверки, пуст ли стек
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного чтения состояния стека
        return data.empty();
        // Возврат true, если стек пуст, иначе false
    }

    int size() {
        // Метод получения текущего количества элементов в стеке
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного доступа к размеру стека
        return data.size();
        // Возврат количества элементов в стеке
    }
};


// ================================================================
// QUEUE
// ================================================================
class Queue {
    // Класс Queue реализует очередь на основе контейнера vector (FIFO)
private:
    vector<int> data;
    // Вектор для хранения элементов очереди
    size_t frontIdx;
    // Индекс, указывающий на текущий "передний" элемент очереди
    // Используется для эффективного удаления элементов с начала
    mutex mtx;
    // Мьютекс для потокобезопасного доступа к очереди

public:
    Queue() : frontIdx(0) {}
    // Конструктор класса Queue
    // Инициализация frontIdx нулем (очередь пуста)
    void enqueue(int v) {
        // Метод добавления элемента в конец очереди
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного добавления
        data.push_back(v);
        // Добавление элемента v в конец вектора
    }

    bool dequeue() {
        // Метод удаления элемента из начала очереди (FIFO)
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного удаления
        if (frontIdx >= data.size()) return false;
        // Проверка: если очередь пуста (индекс переднего элемента
        // превышает или равен размеру вектора), удаление невозможно
        frontIdx++;
        // Сдвиг индекса "переднего" элемента вперед,
        // фактически удаляя элемент из очереди
        return true;
        // Возврат true, если удаление прошло успешно
    }

    bool isEmpty() {
        // Метод проверки, пуста ли очередь
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для потокобезопасного чтения состояния
        return frontIdx >= data.size();
        // Возврат true, если все элементы "выведены" из очереди
    }

    int size() {
        // Метод получения текущего количества элементов в очереди
        lock_guard<mutex> lock(mtx);
        // Блокировка мьютекса для безопасного чтения размера
        return data.size() - frontIdx;
        // Количество элементов = размер вектора минус индекс переднего элемента
    }
};

// ================================================================
// UTILS
// ================================================================
// Вспомогательная функция для вывода результатов времени выполнения
// последовательной и параллельной версии программы

void printResult(double seq, double par) {
    // seq  — время выполнения последовательного алгоритма (в миллисекундах)
    // par  — время выполнения параллельного алгоритма (в миллисекундах)

#ifdef _OPENMP
    // Если компиляция с поддержкой OpenMP
    int threads = omp_get_max_threads();               // Получение максимального количества потоков, доступных OpenMP
    double speedup = seq / par;                        // Расчёт ускорения (speedup) = время последовательного алгоритма / время параллельного
    double efficiency = speedup / threads;             // Расчёт эффективности (efficiency) = ускорение / количество потоков
    cout << "Sequential time: " << seq << " ms\n";     // Вывод времени выполнения последовательного алгоритма
    cout << "Parallel time:   " << par << " ms\n";     // Вывод времени выполнения параллельного алгоритма
    cout << "Speedup:         " << speedup << "\n";    // Вывод ускорения
    cout << "Efficiency:      " << efficiency << "\n"; // Вывод эффективности использования потоков
#else
    // Если OpenMP не поддерживается, выводим только последовательное время
    cout << "Sequential time: " << seq << " ms\n";
#endif
}


// ================================================================
// MAIN TASK FUNCTION
// ================================================================
// Основная функция для выполнения заданий с различными структурами данных

void DataStructuresTask() {
    srand((unsigned)time(nullptr));
    // Инициализация генератора случайных чисел с текущим временем
    // в качестве зерна, чтобы получать разные случайные последовательности при каждом запуске
#ifdef _OPENMP
    cout << "OpenMP enabled | Threads: " << omp_get_max_threads() << "\n";
    // Если OpenMP доступен, выводим сообщение о включении параллельности
    // и количество доступных потоков
#else
    cout << "OpenMP NOT enabled\n";
    // Если OpenMP не доступен, выводим сообщение о его отсутствии
#endif

    int N; // Переменная для хранения количества элементов, которое введет пользователь
    cout << "Enter N: "; // Запрос ввода числа элементов для работы с структурами данных
    cin >> N; // Считывание значения N с клавиатуры

    // ============================================================
    // LINKED LIST
    // ============================================================
    cout << "\n===== LINKED LIST =====\n";
    // Вывод заголовка для раздела с односвязным списком

    LinkedList listSeq, listPar;
    // Создание двух экземпляров LinkedList:
    // listSeq — для последовательных операций
    // listPar — для параллельных операций

    // --- Генерация случайных чисел ---
    random_device rd;                           // Источник энтропии для генератора случайных чисел
    mt19937 gen(rd());                       // Генератор случайных чисел Мерсенна-Твистера, инициализированный rd()
    uniform_int_distribution<> dist(RAND_MIN_VAL, RAND_MAX_VAL); // Определение равномерного распределения чисел в диапазоне [RAND_MIN_VAL, RAND_MAX_VAL]
    for (int i = 0; i < 1000; ++i) {                  // Цикл для заполнения списка 10 случайными элементами
        listSeq.add(dist(gen));             // Добавление случайного числа в последовательный список
        listPar.add(dist(gen));             // Добавление того же случайного числа в "параллельный" список
    }

    cout << "Initial size: " << listSeq.size() << "\n"; // Вывод начального размера списка (должно быть 10)

    // ---- ADD ----
    auto t1 = clk::now(); // Запоминаем текущее время перед последовательным добавлением
    for (int i = 0; i < N; ++i)
        listSeq.add(dist(gen));// Последовательно добавляем N случайных элементов в listSeq
    auto t2 = clk::now();// Фиксируем время после завершения добавления
    double seqAdd = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения последовательного добавления в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным добавлением
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i)
        listPar.add(dist(gen));
    // Параллельное добавление N случайных элементов в listPar
    // Если OpenMP включен, цикл распределяется между потоками
    t2 = clk::now(); // Фиксируем время после параллельного добавления
    double parAdd = chrono::duration<double, milli>(t2 - t1).count(); // Вычисляем время выполнения параллельного добавления в миллисекундах
    cout << "After add size: " << listSeq.size() << "\n"; // Вывод размера списка после последовательного добавления
    cout << "After add size: " << listPar.size() << "\n"; // Вывод размера списка после параллельного добавления

    printResult(seqAdd, parAdd);
    // Вызов функции printResult для отображения:
    // - времени выполнения последовательного и параллельного алгоритма
    // - ускорения (speedup) и эффективности (efficiency)


    // ---- REMOVE ----
    t1 = clk::now(); // Запоминаем текущее время перед последовательным удалением
    for (int i = 0; i < N; ++i)
        listSeq.remove();// Последовательно удаляем N элементов из listSeq
    t2 = clk::now();// Фиксируем время после завершения последовательного удаления
    double seqRem = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения последовательного удаления в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным удалением
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i)
        listPar.remove();
    // Параллельное удаление N элементов из listPar
    // Если OpenMP включен, итерации цикла распределяются между потоками
    t2 = clk::now();// Фиксируем время после параллельного удаления
    double parRem = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения параллельного удаления в миллисекундах

    cout << "After remove size: " << listSeq.size() << "\n";// Вывод размера списка после последовательного удаления
    cout << "After remove size: " << listPar.size() << "\n";// Вывод размера списка после параллельного удаления

    printResult(seqRem, parRem);
    // Вызов функции printResult для отображения:
    // - времени выполнения последовательного и параллельного удаления
    // - ускорения (speedup) и эффективности (efficiency)


    // ---- SEARCH ----
    int key = 7; // Ключ (значение) для поиска в списке
    t1 = clk::now();// Запоминаем время перед началом поиска
    bool found = listSeq.search(key);
    // Выполняем поиск элемента key в последовательном списке listSeq
    // Метод возвращает true, если элемент найден, иначе false
    t2 = clk::now();// Фиксируем время после завершения поиска
    cout << "Search result: " << (found ? "Found" : "Not Found") << "\n"; // Выводим результат поиска: "Found" если элемент найден, "Not Found" если нет
    cout << "Search time: "
         << chrono::duration<double, micro>(t2 - t1).count()
         << " µs\n"; // Вывод времени поиска в микросекундах


    // ============================================================
    // STACK
    // ============================================================
    cout << "\n===== STACK =====\n";
    // Вывод заголовка для раздела со стеком
    Stack stSeq, stPar;
    // Создание двух экземпляров стека:
    // stSeq — последовательный стек
    // stPar — "параллельный" стек (для сравнения с OpenMP)

    for (int i = 0; i < 1000; ++i) {
        stSeq.push(dist(gen));// Добавление случайного числа в последовательный стек
        stPar.push(dist(gen));// Добавление случайного числа в "параллельный" стек
    }

    cout << "Initial size: " << stSeq.size() << "\n";// Вывод начального размера последовательного стека (должно быть 10)

    // PUSH
    t1 = clk::now();// Запоминаем время перед последовательным добавлением элементов
    for (int i = 0; i < N; ++i) stSeq.push(dist(gen));// Последовательно добавляем N случайных элементов в stSeq
    t2 = clk::now();// Фиксируем время после завершения последовательного PUSH

    seqAdd = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения последовательного PUSH в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным PUSH
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i) stPar.push(dist(gen));
    // Параллельное добавление N случайных элементов в stPar
    // Если OpenMP включен, итерации распределяются между потоками
    t2 = clk::now();// Фиксируем время после параллельного PUSH
    parAdd = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения параллельного PUSH в миллисекундах

    printResult(seqAdd, parAdd); // Вызов функции printResult для отображения времени, ускорения и эффективности
    cout << "Size after PUSH (sequential): " << stSeq.size() << "\n";// Вывод размера последовательного стека после PUSH
    cout << "Size after PUSH (parallel):   " << stPar.size() << "\n";// Вывод размера "параллельного" стека после PUSH

    // POP
    t1 = clk::now();// Запоминаем время перед последовательным удалением элементов
    for (int i = 0; i < N; ++i) stSeq.pop();// Последовательно удаляем N элементов из stSeq (с вершины стека)
    t2 = clk::now();// Фиксируем время после завершения последовательного POP
    seqRem = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения последовательного POP в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным POP
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i) stPar.pop();
    // Параллельное удаление N элементов из stPar
    // Если OpenMP включен, итерации распределяются между потоками
    t2 = clk::now();// Фиксируем время после параллельного POP
    parRem = chrono::duration<double, milli>(t2 - t1).count(); // Вычисляем время выполнения параллельного POP в миллисекундах

    printResult(seqRem, parRem);// Вызов функции printResult для отображения времени, ускорения и эффективности
    cout << "Size after POP (sequential): " << stSeq.size() << "\n";// Вывод размера последовательного стека после POP
    cout << "Size after POP (parallel):   " << stPar.size() << "\n";// Вывод размера "параллельного" стека после POP


    t1 = clk::now();// Запоминаем время перед вызовом метода isEmpty()
    bool empty = stSeq.isEmpty();
    // Проверка, пуст ли стек stSeq
    // Метод возвращает true, если стек пуст, иначе false
    t2 = clk::now();// Фиксируем время после вызова isEmpty()
    cout << "isEmpty(): " << empty
         << " | Time: "
         << chrono::duration<double, micro>(t2 - t1).count()
         << " µs\n";
    // Вывод результата проверки пустоты стека
    // и времени выполнения метода в микросекундах

    // ============================================================
    // QUEUE
    // ============================================================
    cout << "\n===== QUEUE =====\n"; // Вывод заголовка для раздела с очередью
    Queue qSeq, qPar;
    // Создание двух экземпляров очереди:
    // qSeq — последовательная очередь
    // qPar — "параллельная" очередь (для сравнения с OpenMP)

    for (int i = 0; i < 1000; ++i) {
        qSeq.enqueue(dist(gen));// Добавление случайного числа в конец последовательной очереди
        qPar.enqueue(dist(gen));// Добавление случайного числа в конец "параллельной" очереди
    }

    cout << "Initial size: " << qSeq.size() << "\n";// Вывод начального размера последовательной очереди (должно быть 10)

    // ENQUEUE
    t1 = clk::now();// Запоминаем время перед последовательным добавлением элементов в очередь
    for (int i = 0; i < N; ++i) qSeq.enqueue(dist(gen));// Последовательно добавляем N случайных элементов в конец очереди qSeq
    t2 = clk::now();// Фиксируем время после завершения последовательного ENQUEUE

    seqAdd = chrono::duration<double, milli>(t2 - t1).count(); // Вычисляем время выполнения последовательного ENQUEUE в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным ENQUEUE
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i) qPar.enqueue(dist(gen));
    // Параллельное добавление N элементов в очередь qPar
    // Если OpenMP включен, итерации распределяются между потоками
    t2 = clk::now(); // Фиксируем время после параллельного ENQUEUE
    parAdd = chrono::duration<double, milli>(t2 - t1).count(); // Вычисляем время выполнения параллельного ENQUEUE в миллисекундах

    printResult(seqAdd, parAdd);
    // Вызов функции printResult для отображения:
    // - времени выполнения последовательного и параллельного ENQUEUE
    // - ускорения и эффективности

    cout << "Size after ENQUEUE (sequential): " << qSeq.size() << "\n"; // Вывод размера последовательной очереди после ENQUEUE
    cout << "Size after ENQUEUE (parallel):   " << qPar.size() << "\n"; // Вывод размера "параллельной" очереди после ENQUEUE


    // DEQUEUE
    t1 = clk::now(); // Запоминаем время перед последовательным удалением элементов из очереди
    for (int i = 0; i < N; ++i) qSeq.dequeue(); // Последовательно удаляем N элементов с начала очереди qSeq
    t2 = clk::now(); // Фиксируем время после завершения последовательного DEQUEUE

    seqRem = chrono::duration<double, milli>(t2 - t1).count();// Вычисляем время выполнения последовательного DEQUEUE в миллисекундах

    t1 = clk::now();// Запоминаем время перед параллельным DEQUEUE
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (int i = 0; i < N; ++i) qPar.dequeue();
    // Параллельное удаление N элементов из очереди qPar
    // Если OpenMP включен, итерации распределяются между потоками

    t2 = clk::now();// Фиксируем время после параллельного DEQUEUE
    parRem = chrono::duration<double, milli>(t2 - t1).count(); // Вычисляем время выполнения параллельного DEQUEUE в миллисекундах
    printResult(seqRem, parRem);
    // Вызов функции printResult для отображения:
    // - времени выполнения последовательного и параллельного DEQUEUE
    // - ускорения (speedup) и эффективности (efficiency)

    cout << "Size after DEQUEUE (sequential): " << qSeq.size() << "\n"; // Вывод размера последовательной очереди после DEQUEUE
    cout << "Size after DEQUEUE (parallel):   " << qPar.size() << "\n"; // Вывод размера "параллельной" очереди после DEQUEUE

    t1 = clk::now(); // Запоминаем время перед вызовом метода isEmpty() для очереди

    empty = qSeq.isEmpty();
    // Проверка, пуста ли последовательная очередь qSeq
    // Метод возвращает true, если очередь пуста, иначе false

    t2 = clk::now(); // Фиксируем время после вызова isEmpty()

    cout << "isEmpty(): " << empty
         << " | Time: "
         << chrono::duration<double, micro>(t2 - t1).count()
         << " µs\n";
    // Вывод результата проверки пустоты очереди
    // и времени выполнения метода в микросекундах

    cout << "\nTASK COMPLETED SUCCESSFULLY\n";
    // Вывод сообщения о завершении основной задачи
}

int main() {
    DataStructuresTask();
    return 0;
}
