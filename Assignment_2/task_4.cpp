#include <iostream>  // Подключение библиотеки ввода-вывода
#include <vector>    // Подключение контейнера vector
#include <random>    // Подключение генератора случайных чисел
#include <chrono>    // Подключение библиотеки для замера времени
#include <omp.h>     // Подключение библиотеки OpenMP для параллельных вычислений

using namespace std; // Использование пространства имен std

// Константы для диапазона случайных чисел
constexpr int RAND_MIN_VAL = -1000000; // Минимальное значение
constexpr int RAND_MAX_VAL = 1000000; // Максимальное значение

// Проверка, отсортирован ли массив
bool isSorted(int* arr, int size) {
    for (int i = 0; i < size - 1; i++) { // Проход по всем элементам кроме последнего
        if (arr[i] > arr[i + 1])         // Если текущий элемент больше следующего
            return false;                // Значит, массив не отсортирован
    }
    return true;                         // Если нарушений не найдено, массив отсортирован
}

// ===================================================
// Merge Sort — общие вспомогательные функции
// ===================================================

// Функция слияния двух отсортированных подмассивов
void merge(int* arr, int l, int m, int r) {
    int n1 = m - l + 1; // Размер левого подмассива
    int n2 = r - m;     // Размер правого подмассива

    vector<int> L(n1), R(n2); // Создание временных векторов для хранения частей

    for (int i = 0; i < n1; i++) // Копирование данных в левый вектор
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) // Копирование данных в правый вектор
        R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l; // Индексы для обхода L, R и основного массива

    while (i < n1 && j < n2) { // Слияние, пока в обоих векторах есть элементы
        if (L[i] <= R[j])      // Если элемент слева меньше или равен
            arr[k++] = L[i++]; // Берем элемент из левого вектора
        else                   // Иначе
            arr[k++] = R[j++]; // Берем элемент из правого вектора
    }

    while (i < n1) arr[k++] = L[i++]; // Докопирование оставшихся элементов левого вектора
    while (j < n2) arr[k++] = R[j++]; // Докопирование оставшихся элементов правого вектора
}

// ===================================================
// Последовательный Merge Sort
// ===================================================
void mergeSortSequential(int* arr, int l, int r) {
    if (l < r) {                            // Базовое условие рекурсии: если в отрезке больше одного элемента
        int m = l + (r - l) / 2;            // Поиск середины для разделения
        mergeSortSequential(arr, l, m);     // Рекурсивная сортировка левой половины
        mergeSortSequential(arr, m + 1, r); // Рекурсивная сортировка правой половины
        merge(arr, l, m, r);                // Слияние двух отсортированных половин
    }
}

// ===================================================
// Параллельный Merge Sort (OpenMP)
// ===================================================
void mergeSortParallel(int* arr, int l, int r, int depth = 0) {
    if (l < r) {                            // Проверка, есть ли элементы для сортировки
        int m = l + (r - l) / 2;            // Вычисление середины

        if (depth < 4) { // ограничение глубины параллелизма, чтобы не создавать слишком много потоков
#pragma omp parallel sections               // Директива OpenMP для выполнения блоков кода параллельно
            {
#pragma omp section                         // Первая секция для левой части
                mergeSortParallel(arr, l, m, depth + 1);
#pragma omp section                         // Вторая секция для правой части
                mergeSortParallel(arr, m + 1, r, depth + 1);
            }
        } else {                            // Если достигнута макс. глубина, переходим на последовательный режим
            mergeSortSequential(arr, l, m);
            mergeSortSequential(arr, m + 1, r);
        }

        merge(arr, l, m, r);                // Слияние результатов (всегда последовательно на данном этапе)
    }
}

// Функция для вывода начала и конца массива
void printArrayEdges(int* arr, int size) {
    int count = min(10, size); // Количество выводимых элементов (макс. 10)

    cout << "Первые " << count << " элементов: ";
    for (int i = 0; i < count; i++)
        cout << arr[i] << " "; // Печать первых элементов
    cout << endl;

    cout << "Последние " << count << " элементов: ";
    for (int i = size - count; i < size; i++)
        cout << arr[i] << " "; // Печать последних элементов
    cout << endl;
}

// ===================================================
// Тестирование и бенчмарк
// ===================================================
void runTest(int size) {
    cout << "\n========== Размер массива: " << size << " ==========\n";

    int* originalArr = new int[size]; // Выделение памяти под исходный массив

    random_device rd;                 // Инициализация источника энтропии
    mt19937 gen(rd());                // Генератор Вихрь Мерсенна
    uniform_int_distribution<> dist(RAND_MIN_VAL, RAND_MAX_VAL); // Равномерное распределение

    for (int i = 0; i < size; i++)
        originalArr[i] = dist(gen);   // Заполнение массива случайными числами

    // Лямбда-функция для проведения замера времени
    auto benchmark = [&](string mode, void (*sortFunc)(int*, int, int)) {
        int* tempArr = new int[size];           // Временный массив для сортировки
        copy(originalArr, originalArr + size, tempArr); // Копирование исходных данных

        auto start = chrono::high_resolution_clock::now(); // Фиксация времени начала
        sortFunc(tempArr, 0, size - 1);                    // Вызов функции сортировки
        auto end = chrono::high_resolution_clock::now();   // Фиксация времени окончания

        chrono::duration<double> elapsed = end - start;    // Расчет длительности

        cout << "Merge Sort | Режим: " << mode
             << " | Время: " << elapsed.count() * 1000 << " мс | " // Вывод в миллисекундах
             << (isSorted(tempArr, size) ? "Массив отсортирован" : "Ошибка сортировки")
             << endl;

        printArrayEdges(tempArr, size); // Вывод краев массива для визуальной проверки
        cout << "----------------------------------------\n";

        delete[] tempArr; // Освобождение временной памяти
    };

    // Тест последовательной версии
    benchmark("Последовательный", mergeSortSequential);

    // Тест параллельной версии с использованием обертки
    benchmark("Параллельный", [](int* arr, int l, int r) {
        mergeSortParallel(arr, l, r, 0);
    });

    delete[] originalArr; // Освобождение основной памяти
}

// ===================================================
// Главная функция
// ===================================================
int MergeSortMainFunction() {
    omp_set_num_threads(4); // Установка количества потоков для OpenMP

    int sizes[] = {100, 1000, 10000, 100000, 1000000}; // Массив размеров для тестов
    for (int size : sizes) {
        runTest(size); // Запуск теста для каждого размера
    }

    return 0; // Возврат успешного статуса
}
int main() {
        MergeSortMainFunction();
        return 0;
}
