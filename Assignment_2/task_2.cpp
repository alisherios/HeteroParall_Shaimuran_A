#include <iostream>     // Библиотека для ввода и вывода данных
#include <random>       // Библиотека для генерации случайных чисел
#include <chrono>       // Библиотека для измерения времени выполнения
#include <iomanip>      // Библиотека для форматированного вывода
#include <omp.h>        // Библиотека для поддержки OpenMP

using namespace std;    // Использование стандартного пространства имён

// Функция для поиска минимального и максимального значения массива
// в последовательном и параллельном режимах
int MinMaxOfArray() {

    constexpr int SIZE = 10000;        // Размер массива (10 000 элементов)
    constexpr int RAND_MIN_VAL = 1;     // Минимальное возможное значение элемента массива
    constexpr int RAND_MAX_VAL = 1000000; // Максимальное возможное значение элемента массива

    int* arr = new int[SIZE];           // Динамическое выделение памяти под массив целых чисел

    random_device rd;                   // Источник энтропии для инициализации генератора
    mt19937 gen(rd());                  // Генератор псевдослучайных чисел (Mersenne Twister)
    uniform_int_distribution<> dist(RAND_MIN_VAL, RAND_MAX_VAL);
                                        // Равномерное распределение чисел в заданном диапазоне

    // Заполнение массива случайными числами
    for (int i = 0; i < SIZE; i++) {
        arr[i] = dist(gen);             // Генерация и запись случайного числа в массив
    }

    // ==================================================
    // Последовательный поиск минимального и максимального значений
    // ==================================================
    int min_seq = arr[0];               // Инициализация минимального значения первым элементом
    int max_seq = arr[0];               // Инициализация максимального значения первым элементом

    auto start_seq = chrono::high_resolution_clock::now();
                                        // Начало измерения времени последовательного алгоритма

    // Последовательный проход по массиву
    for (int i = 1; i < SIZE; i++) {
        if (arr[i] < min_seq)           // Проверка на новое минимальное значение
            min_seq = arr[i];
        if (arr[i] > max_seq)           // Проверка на новое максимальное значение
            max_seq = arr[i];
    }

    auto end_seq = chrono::high_resolution_clock::now();
                                        // Конец измерения времени последовательного алгоритма
    chrono::duration<double> time_seq = end_seq - start_seq;
                                        // Время выполнения последовательной версии

    // ==================================================
    // Параллельный поиск минимального и максимального значений (OpenMP)
    // ==================================================
    int min_par = arr[0];               // Начальное значение минимума для параллельного поиска
    int max_par = arr[0];               // Начальное значение максимума для параллельного поиска

    auto start_par = chrono::high_resolution_clock::now(); // Начало измерения времени параллельного алгоритма

    #pragma omp parallel for reduction(min:min_par) reduction(max:max_par)
                                        // Параллельный цикл с редукцией минимума и максимума
    for (int i = 0; i < SIZE; i++) {
        if (arr[i] < min_par)           // Локальное сравнение для поиска минимума
            min_par = arr[i];
        if (arr[i] > max_par)           // Локальное сравнение для поиска максимума
            max_par = arr[i];
    }

    auto end_par = chrono::high_resolution_clock::now();
                                        // Конец измерения времени параллельного алгоритма
    chrono::duration<double> time_par = end_par - start_par;
                                        // Время выполнения параллельной версии

    // ==================================================
    // Вывод результатов работы программы
    // ==================================================
    cout << fixed << setprecision(10);  // Установка формата вывода времени

    cout << "Последовательный поиск." << endl;
    cout << "Размер массива: " << SIZE << endl;
    cout << "Минимальное значение: " << min_seq << endl;
    cout << "Максимальное значение: " << max_seq << endl;
    cout << "Время выполнения: " << time_seq.count() << " секунды\n" << endl;

    cout << "Параллельный поиск с использованием OpenMP." << endl;
    cout << "Размер массива: " << SIZE << endl;
    cout << "Минимальное значение: " << min_par << endl;
    cout << "Максимальное значение: " << max_par << endl;
    cout << "Время выполнения: " << time_par.count() << " секунды\n" << endl;

    delete[] arr;                       // Освобождение динамически выделенной памяти
    return 0;                           // Успешное завершение функции
}
int main() {
        MinMaxOfArray();
        return 0;
}
