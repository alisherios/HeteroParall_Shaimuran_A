#include <iostream>     // Подключение библиотеки для ввода и вывода данных
#include <vector>       // Подключение контейнера vector (в коде используется косвенно)
#include <random>       // Подключение генераторов случайных чисел
#include <chrono>       // Подключение библиотеки для измерения времени
#include <omp.h>        // Подключение библиотеки OpenMP
#include <algorithm>    // Подключение алгоритмов swap и copy

using namespace std;    // Использование стандартного пространства имён

// ============================================================
// Константы диапазона генерации случайных чисел
// ============================================================
constexpr int RAND_MIN_VAL = -1000;   // Минимальное значение случайного числа
constexpr int RAND_MAX_VAL = 1000;    // Максимальное значение случайного числа

// ============================================================
// Функция проверки: отсортирован ли массив
// ============================================================
bool isSorted(int* arr, int size) {          // Функция принимает массив и его размер
    for (int i = 0; i < size - 1; i++) {     // Проход по всем элементам массива
        if (arr[i] > arr[i + 1])             // Проверка нарушения порядка сортировки
            return false;                    // Если порядок нарушен — массив не отсортирован
    }
    return true;                             // Если нарушений нет — массив отсортирован
}

// ============================================================
// 1. Параллельная пузырьковая сортировка (Odd-Even Sort)
// ============================================================
void parallelBubbleSort(int* arr, int n) {   // Функция пузырьковой сортировки
    for (int i = 0; i < n; i++) {             // Выполняем n фаз сортировки

        // Чётная фаза
        if (i % 2 == 0) {                     // Проверка на чётную итерацию
            #pragma omp parallel for          // Параллельный цикл OpenMP
            for (int j = 0; j < n - 1; j += 2) { // Обработка чётных пар элементов
                if (arr[j] > arr[j + 1])      // Если элементы расположены неверно
                    swap(arr[j], arr[j + 1]); // Меняем их местами
            }
        }
        // Нечётная фаза
        else {
            #pragma omp parallel for          // Параллельный цикл OpenMP
            for (int j = 1; j < n - 1; j += 2) { // Обработка нечётных пар элементов
                if (arr[j] > arr[j + 1])      // Проверка порядка элементов
                    swap(arr[j], arr[j + 1]); // Обмен элементов
            }
        }
    }
}

// ============================================================
// 2. Параллельная сортировка выбором
// ============================================================
void parallelSelectionSort(int* arr, int n) { // Функция сортировки выбором
    for (int i = 0; i < n - 1; i++) {          // Перебор элементов массива

        int min_idx = i;                       // Индекс минимального элемента
        int min_val = arr[i];                  // Значение минимального элемента

        #pragma omp parallel                  // Начало параллельной области
        {
            int local_min_idx = min_idx;       // Локальный индекс минимума для потока
            int local_min_val = min_val;       // Локальное минимальное значение

            #pragma omp for nowait             // Параллельный цикл без ожидания
            for (int j = i + 1; j < n; j++) {  // Поиск минимума в оставшейся части
                if (arr[j] < local_min_val) { // Если найден меньший элемент
                    local_min_val = arr[j];   // Обновляем локальный минимум
                    local_min_idx = j;        // Обновляем индекс
                }
            }

            #pragma omp critical               // Критическая секция
            {
                if (local_min_val < min_val) {// Обновление глобального минимума
                    min_val = local_min_val;
                    min_idx = local_min_idx;
                }
            }
        }

        swap(arr[i], arr[min_idx]);            // Обмен текущего элемента с минимальным
    }
}

// ============================================================
// 3. Параллельная сортировка вставками (Shell Sort)
// ============================================================
void parallelInsertionSort(int* arr, int n) { // Функция сортировки вставками

    for (int gap = n / 2; gap > 0; gap /= 2) { // Выбор шага (Shell Sort)

        #pragma omp parallel for               // Параллельная обработка групп
        for (int i = 0; i < gap; i++) {        // Перебор подмассивов

            for (int j = i + gap; j < n; j += gap) { // Вставка с шагом
                int temp = arr[j];             // Сохраняем текущий элемент
                int k = j;                     // Индекс для сдвига элементов

                while (k >= gap && arr[k - gap] > temp) { // Сдвиг элементов
                    arr[k] = arr[k - gap];
                    k -= gap;
                }
                arr[k] = temp;                 // Вставка элемента на нужное место
            }
        }
    }
}
// ============================================================
// 4. Сортировка вставкой (ограниченный параллелизм)
// ============================================================
void insertionSortParallel(int* arr, int size) {   // Функция сортировки вставками
    for (int i = 1; i < size; ++i) {                // Перебор элементов массива
        int key = arr[i];                           // Текущий вставляемый элемент
        int j = i - 1;                              // Индекс предыдущего элемента

        // Сдвиг элементов вправо, пока не найдено место для вставки
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];                    // Сдвиг элемента
            j--;                                    // Переход к предыдущему элементу
        }

        arr[j + 1] = key;                           // Вставка элемента на нужное место
    }
}

// ============================================================
// Функция тестирования сортировок
// ============================================================
void runTest(int size) {                        // Функция тестирования
    cout << "\n--- Тестирование массива размером: "
         << size << " ---" << endl;

    int* originalArr = new int[size];           // Выделение памяти под массив

    random_device rd;                           // Источник энтропии
    mt19937 gen(rd());                          // Генератор Mersenne Twister
    uniform_int_distribution<> dist(RAND_MIN_VAL, RAND_MAX_VAL); // Диапазон

    for (int i = 0; i < size; i++)              // Заполнение массива
        originalArr[i] = dist(gen);

    auto benchmark = [&](string name,
                         void (*sortFunc)(int*, int)) {

        int* tempArr = new int[size];           // Копия массива
        copy(originalArr, originalArr + size, tempArr);

        auto start_seq = chrono::high_resolution_clock::now(); // Начало измерения
        sortFunc(tempArr, size);                // Выполнение сортировки
        auto end_seq = chrono::high_resolution_clock::now();   // Конец измерения

        chrono::duration<double> diff = end_seq - start_seq;   // Время выполнения

        cout << "Алгоритм: " << name
             << " | Время выполнения: "
             << diff.count() * 1000 << " мс | ";

        if (isSorted(tempArr, size))
            cout << "Массив успешно отсортирован." << endl;
        else
            cout << "Ошибка сортировки!" << endl;

        delete[] tempArr;                       // Освобождение памяти
    };

    benchmark("Пузырьковая сортировка (Odd-Even)", parallelBubbleSort);
    benchmark("Сортировка выбором", parallelSelectionSort);
    benchmark("Сортировка вставками (Shell)", parallelInsertionSort);
    benchmark("Сортировка вставкой (ограниченный параллелизм)", insertionSortParallel);

    delete[] originalArr;                       // Освобождение памяти
}

// ============================================================
// Главная функция
// ============================================================
int SortingAlgorithmsUsingOpenMP() {

    omp_set_num_threads(4);                     // Установка количества потоков

    int sizes[] = {10, 100, 1000, 10000, 100000}; // Размеры массивов

    for (int size : sizes) {                    // Запуск тестов
        runTest(size);
    }

    return 0;                                   // Завершение программы
}
int main() {
    SortingAlgorithmsUsingOpenMP();
    return 0;
}
