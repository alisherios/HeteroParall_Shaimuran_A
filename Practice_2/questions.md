# Контрольные вопросы к Практическая работа №2 Параллельная реализация простых алгоритмов сортировки (пузырьком, выбором, вставкой) на CPU с использованием OpenMP

## 1. В чём основные отличия алгоритмов сортировки пузырьком, выбором и вставкой?

* **Сортировка пузырьком (Bubble Sort):** Сравнивает соседние элементы и постепенно «всплывает» больший элемент к концу массива. Хорошо работает на небольших или частично отсортированных массивах. Сложность: O(n²).
* **Сортировка выбором (Selection Sort):** На каждом шаге находит минимальный элемент в неотсортированной части массива и перемещает его в начало. Делает меньше обменов, чем пузырёк, но имеет ту же временную сложность O(n²).
* **Сортировка вставкой (Insertion Sort):** Последовательно берет элементы и вставляет их в правильное место в уже отсортированной части массива. Эффективна для небольших или почти отсортированных массивов. Время выполнения: O(n²) в худшем случае, O(n) — в лучшем.

## 2. Почему параллельная реализация сортировки вставкой сложнее для выполнения с использованием OpenMP?

Сортировка вставкой сильно зависит от **предыдущих шагов**: чтобы вставить текущий элемент, необходимо знать уже отсортированную часть массива. Эта последовательная зависимость затрудняет распараллеливание, так как потоки не могут работать независимо без сложной синхронизации.

## 3. Какие директивы OpenMP были использованы для параллельной реализации алгоритмов?

* `#pragma omp parallel for` — распараллеливает внешний цикл сортировки между потоками.
* `#pragma omp critical` — защищает критические секции, чтобы одновременно выполнялся только один поток.
* `#pragma omp barrier` — синхронизирует потоки в определённой точке программы.
* `reduction` — безопасно объединяет локальные результаты потоков (например, при поиске минимального или максимального элемента).

## 4. Какие преимущества и недостатки параллельной реализации алгоритмов сортировки на CPU?

**Преимущества:**

* Существенное ускорение обработки больших массивов за счет одновременной работы всех ядер.
* Возможность использовать многоядерные процессоры более эффективно.

**Недостатки:**

* Накладные расходы на создание и управление потоками.
* Необходимость синхронизации потоков и защита от конфликтов в общей памяти (race conditions).
* Более сложная реализация и отладка по сравнению с последовательной сортировкой.

## 5. Как можно измерить производительность программы в C++?

Используется библиотека `<chrono>`: фиксируется время начала и конца выполнения функции, затем вычисляется разница. Пример:

```cpp
auto start = std::chrono::high_resolution_clock::now();
// вызов функции сортировки
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
```

## 6. Как изменяется производительность сортировок при увеличении числа потоков?

Производительность обычно **растет** с увеличением числа потоков (время выполнения падает), но до определенного предела:

* ограничено количеством физических ядер;
* при чрезмерном количестве потоков накладные расходы на управление и переключение контекста могут замедлять работу;
* слишком много потоков может вызвать конкуренцию за ресурсы и уменьшить эффективность.

## 7. В каких ситуациях параллельная сортировка может быть менее эффективной, чем последовательная?

* **Малые объемы данных:** накладные расходы на создание потоков и синхронизацию превышают выигрыш от параллельности.
* **Частая синхронизация:** использование `critical` или `barrier` заставляет потоки простаивать.
* **Сильная зависимость шагов алгоритма:** например, сортировка вставкой, где элементы нужно вставлять в уже отсортированную последовательность.
Если хочешь, я могу дополнительно сделать **сводную таблицу всех алгоритмов сортировки (пузырёк, выбор, вставка) с их особенностями, сложностями и возможностью параллельной реализации**, чтобы визуально всё было наглядно.

Хочешь, чтобы я сделал такую таблицу?
